<!--
License CC0 - http://creativecommons.org/publicdomain/zero/1.0/
To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.

^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.
-Otavio Good
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>fontpage</title>
  </head>
  <body>

    <script type="text/javascript">
      symbols = ["‚èÆ‚è™‚è¥‚è∫‚èπ‚èµ‚è∏‚è©‚è≠‚ô©‚ô™‚ô´‚ô¨‚ô≠‚ôÆ‚ôØ",
        "‚Üê‚Üë‚Üí‚Üì‚Üî‚Üï‚Üñ‚Üó‚Üò‚Üô‚Ü∫‚Üª‚òÖ‚òª  ",
        "Œ±Œ≤Œ≥Œ¥ŒµŒ∏ŒªŒºŒæœÄœÅœÉœÑœÜœàœâ",
        "ŒìŒîŒòŒõŒ†Œ£Œ¶Œ®Œ©‚àû∆í‚àò‚à´‚àÇ‚àá‚àö"];
        // "Œ±Œ≤Œ≥Œ¥ŒµŒ∏ŒªŒºŒæœÄœÅœÉœÑœÜœàœâ"
        // "ŒìŒîŒòŒõŒ†Œ£Œ¶Œ®Œ©"
        // "‚àá‚àö‚àû‚àò‚à´"
        // "‚èÆ‚è™‚è¥‚è∫‚èπ‚è∏‚èµ‚è©‚è≠"
        // "üì∑üìπüìΩüï®üï™üñÆ"
        // "‚òÄ‚òÅ‚òÇ‚òÉ‚á¶‚áß‚á®‚á©"
        // "‚ô°‚ô•"


      // 4 for highest quality. (6 hour run)
      downCount = 0;
      cellSize = (64 * Math.pow(2, downCount)) | 0;
      texSize = (1024 * Math.pow(2, downCount)) | 0;

      tileCount = (texSize / cellSize) | 0;
      bufferF = new Float32Array(texSize * texSize);
      widthF = texSize;
      heightF = texSize;
      var myImageData;
      var newImg;
      function createTextCanvas(color, font) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var fontStrA = 'bold ' + ((cellSize * 0.9218) + 'px ') + (font || 'Helvetica');
        var fontStrB = 'bold ' + ((cellSize * 0.78125) + 'px ') + (font || 'Noto mono');
        var fontStrC = '' + ((cellSize - 14) + 'px ') + (font || 'Symbola');
        var fontStrD = '' + ((cellSize - 14) + 'px ') + (font || 'Apple Symbols');
        canvas.width = texSize;
        canvas.height = texSize;
        canvas.style.backgroundColor = 'rgba(100, 40, 60, 1.0)';
        ctx.fillRect(0, 0, texSize, texSize);
        for (var y = 0; y < tileCount; y++) {
          for (var x = 0; x < tileCount; x++) {
            ctx.fillRect((x+1)*cellSize-1,0,1,canvas.width);
            ctx.fillRect(0, (y+1)*cellSize-1, canvas.width, 1);
          }
        }
        ctx.fillStyle = color || 'white';
        for (var y = 0; y < tileCount; y++) {
          for (var x = 0; x < tileCount; x++) {
            ctx.font = fontStrB;
            var text = String.fromCharCode(x + y * tileCount)
            if (y <= 1) text = symbols[y][x];
            if ((y==8) || (y==9)) text = symbols[y-6][x];
            if ((y==1) && (x==13)) ctx.font = fontStrD;
            if ((y==1) && (x==14)) text = "üï®";
            if ((y==1) && (x==15)) text = "üï™";
            var xoff = cellSize * 0.2656 //17;
            var posx = xoff + x * cellSize;
            var posy = y * cellSize + cellSize / 2 + cellSize / 3.75;
            if ((y==1) && (x<10)) {
              ctx.font = fontStrA;
              posy += cellSize * 0.0625;
              if (x == 4) posy -= cellSize * 0.09375;
            }
            if ((y==0) && (x<9)) {
              ctx.font = fontStrC;
              posy -= cellSize * 0.046875;
            }
            mw = ctx.measureText(text).width;
            if (y <= 1) posx = (cellSize-mw) / 2 + x * cellSize;  // Center symbols
            ctx.fillText(text, posx, posy);
          }
        }

        myImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        for (var y = 0; y < heightF; y++) {
          for (var x = 0; x < widthF; x++) {
            SetPixelG(myImageData, x, y, 0);
            SetPixelB(myImageData, x, y, 0);
            SetPixelF(x, y, 0);
          }
        }

        var pointsOnLinePairs = Vectorize(myImageData);
        var pointsOnLines = [];
        var divisions = 4.0;
        for (var i = 0; i < pointsOnLinePairs.length; i++) {
          for (var sub = 0; sub < divisions; sub++) {
            var posA = [pointsOnLinePairs[i][0], pointsOnLinePairs[i][1]];
            var posB = [pointsOnLinePairs[i][2], pointsOnLinePairs[i][3]];
            var current = Lerp2(posA, posB, sub / divisions);
            pointsOnLines.push(current);
          }
        }
        FillDistancePrecise(myImageData, pointsOnLines);

        canvas.width = texSize >> downCount;
        canvas.height = texSize >> downCount;
        newImg = myImageData;
        // Calc gradients from floating point distances
        for (var y = 0; y < newImg.height; y++) {
          for (var x = 0; x < newImg.width; x++) {
            var grad = CalcGradF(x, y);
            var gradScale = cellSize * (254.0/256.0);  // Don't go so far that we clamp. Important thing is good directionality.
            var gradX = (grad[0] * gradScale) | 0;
            var gradY = (grad[1] * gradScale) | 0;
            // gradX /= 2;
            // gradY /= 2;
            gradX += 128;
            gradY += 128;
            gradX = Math.min(255, Math.max(0, gradX));
            gradY = Math.min(255, Math.max(0, gradY));
            SetPixelG(newImg, x, y, gradX);
            SetPixelB(newImg, x, y, gradY);
          }
        }
        for (var i = 0; i < downCount; i++) {
          DownSampleF();
          newImg = DownSample(newImg, ctx);
        }
        CopyInToA(newImg);

        ctx.putImageData(myImageData, 0, 0);
        ctx.putImageData(newImg, 0, 0);

        // ctx.strokeStyle = '#ffffff';
        // for (let pixel of pointsOnLinePairs) {
        //   var tx = 3;
        //   var ty = 0;
        //   var x0 = ((pixel[0] - cellSize*tx) * (16 >> downCount)) | 0;
        //   var y0 = ((pixel[1] - cellSize*ty) * (16 >> downCount)) | 0;
        //   var x1 = ((pixel[2] - cellSize*tx) * (16 >> downCount)) | 0;
        //   var y1 = ((pixel[3] - cellSize*ty) * (16 >> downCount)) | 0;
        //   ctx.beginPath();
        //   ctx.moveTo(x0,y0);
        //   ctx.lineTo(x1,y1);
        //   ctx.stroke();
        // }

        return canvas;
      }

      function IsBorderPixel(imageData, x, y) {
        var pix00 = GetPixelRTile(imageData, x, y, x, y)
        var pixP0 = GetPixelRTile(imageData, x, y, x + 1, y)
        var pixN0 = GetPixelRTile(imageData, x, y, x - 1, y)
        var pix0P = GetPixelRTile(imageData, x, y, x, y + 1)
        var pix0N = GetPixelRTile(imageData, x, y, x, y - 1)
        var on = pix00 >= 128;
        if ((pixP0 >= 128) != on) return true;
        if ((pixN0 >= 128) != on) return true;
        if ((pix0P >= 128) != on) return true;
        if ((pix0N >= 128) != on) return true;
        return false;
      }
      function FindBorderPixels(imageData, tx, ty) {
        var borderPixels = new Set();
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var posx = tx * cellSize + dx;
            var posy = ty * cellSize + dy;
            var border = IsBorderPixel(imageData, posx, posy);
            if (border) borderPixels.add((posx + posy * imageData.width) | 0)
          }
        }
        return borderPixels;
      }
      function FillDistance(imageData, borderPixels, tx, ty) {
        // Clear cell to max value.
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var pixx = tx * cellSize + dx;
            var pixy = ty * cellSize + dy;
            SetPixelF(pixx, pixy, cellSize * 1.5 * cellSize * 1.5);
          }
        }
        // For every border pixel, draw a cone of distance from it. Only draw if smaller than existing
        // pixels so we get minimum distance everywhere.
        for (let pixel of borderPixels) {
          var posx = (pixel % imageData.width);
          var posy = (pixel / imageData.width);
          var pix00 = GetPixelR(imageData, posx | 0, posy | 0);
          //SetPixelB(imageData, posx, posy, 255);
          var lightPixel = GetPixelR(imageData, posx | 0, posy | 0) >= 128;
          for (var dy = 0; dy < cellSize; dy++) {
            var pixy = ty * cellSize + dy;
            var rindex = ((pixy*(imageData.width*4)) + (tx * cellSize*4)) + 0;
            for (var dx = 0; dx < cellSize; dx++) {
              var pixx = tx * cellSize + dx;
              // var currentLight = GetPixelR(imageData, pixx, pixy) >= 128;
              // var currentPix = imageData.data[rindex];
              var currentLight = imageData.data[rindex] >= 128;
              rindex += 4;
              if (currentLight != lightPixel) {
                var distSquared = ((posx-pixx) * (posx-pixx) + (posy-pixy)*(posy-pixy));
                // distSquared -= 0.5;  // Make edge of bitmap the zero crossing.
                var findex = pixy*widthF + pixx;
                var current = bufferF[findex];
                // var current = GetPixelF(pixx, pixy);
                if (distSquared < current) {
                  bufferF[findex] = distSquared;
                  // SetPixelF(pixx, pixy, distSquared);
                } //else {
                  //skip = Math.max(0, (distSquared) - (current) - 30) | 0;
                  //dx += skip;
                  //rindex += skip * 4;
                //}
              }
            }
          }
        }
        var scaler = 1.0 / (Math.pow(2, downCount))
        // Negate inside of letter for signed distance function.
        for (var dy = 0; dy < cellSize; dy++) {
          for (var dx = 0; dx < cellSize; dx++) {
            var pixx = tx * cellSize + dx;
            var pixy = ty * cellSize + dy;
            var currentSign = GetPixelR(imageData, pixx, pixy) >= 128 ? -1 : 1;
            var current = GetPixelF(pixx , pixy);
            current = Math.sqrt(current) - 0.5;  // Make edge of bitmap the zero crossing.
            current *= scaler;
            if (currentSign == -1) {
              SetPixelF(pixx, pixy, -current);
            } else {
              SetPixelF(pixx, pixy, current);
            }
          }
        }

        // blur distances around border pixels. :(
        var bufferF2 = new Float32Array(borderPixels.size);
        var index = 0;
        for (let pixel of borderPixels) {
          var posx = (pixel % imageData.width);
          var posy = (pixel / imageData.width);
          bufferF2[index] = Blur(posx | 0, posy | 0);
          index++;
        }
        index = 0;
        for (let pixel of borderPixels) {
          var posx = (pixel % imageData.width);
          var posy = (pixel / imageData.width);
          SetPixelF(posx | 0, posy | 0, bufferF2[index]);
          index++;
        }
      }

      function FillDistancePrecise(imageData, borderLines) {
        // Clear image to max value.
        for (var i = 0; i < widthF * heightF; i++) {
          bufferF[i] = cellSize * 1.5 * cellSize * 1.5;
        }
        // For every border pixel, draw a cone of distance from it. Only draw if smaller than existing
        // pixels so we get minimum distance everywhere.
        for (let pixel of borderLines) {
          var posx = pixel[0];
          var posy = pixel[1];
          var tx = (posx / cellSize) | 0;
          var ty = (posy / cellSize) | 0;
          var pix00 = GetPixelR(imageData, posx | 0, posy | 0);
          // SetPixelG(imageData, posx | 0, posy | 0, 255);
          var lightPixel = GetPixelR(imageData, posx | 0, posy | 0) >= 128;
          for (var dy = 0; dy < cellSize; dy++) {
            var pixy = ty * cellSize + dy;
            var rindex = ((pixy*(imageData.width*4)) + (tx * cellSize*4)) + 0;
            for (var dx = 0; dx < cellSize; dx++) {
              var pixx = tx * cellSize + dx;
              // var currentLight = GetPixelR(imageData, pixx, pixy) >= 128;
              // var currentPix = imageData.data[rindex];
              var currentLight = imageData.data[rindex] >= 128;
              rindex += 4;
              //if (currentLight != lightPixel) {
                // var deltax = posx - pixx;
                // var deltay = posy - pixy;
                var distSquared = ((posx-pixx) * (posx-pixx) + (posy-pixy)*(posy-pixy));
                // distSquared -= 0.5;  // Make edge of bitmap the zero crossing.
                var findex = pixy*widthF + pixx;
                var current = bufferF[findex];
                // var current = GetPixelF(pixx, pixy);
                if (distSquared < current) {
                  bufferF[findex] = distSquared;
                  // SetPixelF(pixx, pixy, distSquared);
                }
              //}
            }
          }
        }
        var scaler = 1.0 / (Math.pow(2, downCount))
        // Negate inside of letter for signed distance function.
        for (var y = 0; y < heightF; y++) {
          for (var x = 0; x < widthF; x++) {
            var currentSign = GetPixelR(imageData, x, y) >= 128 ? -1 : 1;
            var current = GetPixelF(x, y);
            current = Math.sqrt(current);// - 0.5;  // Make edge of bitmap the zero crossing.
            current *= scaler;
            if (currentSign == -1) {
              SetPixelF(x, y, -current);
            } else {
              SetPixelF(x, y, current);
            }
          }
        }
      }

      function DownSample(imageData, ctx) {
        var w2 = (imageData.width / 2) | 0;
        var h2 = (imageData.height / 2) | 0;
        // var buf2 = new Uint8ClampedArray(w2 * h2);
        var buf2 = ctx.createImageData(w2, h2);
        for (var y = 0; y < h2; y++) {
          for (var x = 0; x < w2; x++) {
            var f0 = GetPixelR(imageData, x * 2, y * 2);
            f0 += GetPixelR(imageData, x * 2 + 1, y * 2);
            f0 += GetPixelR(imageData, x * 2, y * 2 + 1);
            f0 += GetPixelR(imageData, x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            // buf2[y*w2 + x] = f0 | 0;
            SetPixelR(buf2, x, y, f0 | 0);

            f0 = GetPixelG(imageData, x * 2, y * 2);
            f0 += GetPixelG(imageData, x * 2 + 1, y * 2);
            f0 += GetPixelG(imageData, x * 2, y * 2 + 1);
            f0 += GetPixelG(imageData, x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            // buf2[y*w2 + x] = f0 | 0;
            SetPixelG(buf2, x, y, f0 | 0);

            f0 = GetPixelB(imageData, x * 2, y * 2);
            f0 += GetPixelB(imageData, x * 2 + 1, y * 2);
            f0 += GetPixelB(imageData, x * 2, y * 2 + 1);
            f0 += GetPixelB(imageData, x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            // buf2[y*w2 + x] = f0 | 0;
            SetPixelB(buf2, x, y, f0 | 0);

            SetPixelA(buf2,x,y,255);
          }
        }
        return buf2;
      }
      function DownSampleF() {
        var w2 = (widthF / 2) | 0;
        var h2 = (heightF / 2) | 0;
        var buf2 = new Float32Array(w2 * h2);
        for (var y = 0; y < h2; y++) {
          for (var x = 0; x < w2; x++) {
            var f0 = GetPixelF(x * 2, y * 2);
            f0 += GetPixelF(x * 2 + 1, y * 2);
            f0 += GetPixelF(x * 2, y * 2 + 1);
            f0 += GetPixelF(x * 2 + 1, y * 2 + 1);
            f0 *= 0.25;
            buf2[y*w2 + x] = f0;
          }
        }
        bufferF = buf2;
        widthF = w2;
        heightF = h2;
      }
      function CopyInToA(imageData) {
        for (var y = 0; y < heightF; y++) {
          for (var x = 0; x < widthF; x++) {
            var pix = GetPixelF(x, y);
            pix *= 4.0;
            pix = pix | 0;
            pix += 128;
            pix = Math.min(255, Math.max(0, pix));
            SetPixelA(imageData, x, y, pix);
          }
        }
      }

      function CalcGradF(x, y) {
        var pix00 = GetPixelFTile(x, y, x, y)
        var pixP0 = GetPixelFTile(x, y, x + 1, y)
        var pixN0 = GetPixelFTile(x, y, x - 1, y)
        var pix0P = GetPixelFTile(x, y, x, y + 1)
        var pix0N = GetPixelFTile(x, y, x, y - 1)
        var gradX = 0;
        var gradY = 0;
        gradX = pixN0 - pixP0;
        gradY = pix0N - pix0P;
        return [-gradX, -gradY];
      }
      function CalcMomentF(imageData, x, y) {
        var scale = 2;
        var xmoment = 0.0;
        var ymoment = 0.0;
        for (var dy = -scale; dy <= scale; dy++) {
          for (var dx = -scale; dx <= scale; dx++) {
            var pix00 = GetPixelRTile(imageData, x, y, x + dx, y + dy)
            pix00 -= 128;
            xmoment += pix00 * dx;
            ymoment += pix00 * dy;
          }
        }
        var dim = scale*2+1;
        var gradX = xmoment / (256.0*scale*scale);
        var gradY = ymoment / (256.0*scale*scale);
        return [gradX, gradY];
      }
      function Blur(x, y) {
        var scale = 1;
        var total = 0.0;
        for (var dy = -scale; dy <= scale; dy++) {
          for (var dx = -scale; dx <= scale; dx++) {
            var pix00 = GetPixelFTile(x, y, x + dx, y + dy)
            total += pix00;
          }
        }
        var dim = scale*2+1;
        total /= dim * dim;
        return total;
      }
      function InRange(imageData, x, y) {
        if (x < 0) return false;
        if (y < 0) return false;
        if (x >= imageData.width) return false;
        if (y >= imageData.height) return false;
        return true;
      }
      function GetPixelBilinear(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;

        var floorX = x | 0;
        var floorY = y | 0;
        var remainderX = x - floorX;
        var remainderY = y - floorY;
        var pix00 = GetPixelR(imageData, floorX, floorY);
        var pix10 = GetPixelR(imageData, floorX + 1, floorY);
        var pix01 = GetPixelR(imageData, floorX, floorY + 1);
        var pix11 = GetPixelR(imageData, floorX + 1, floorY + 1);

        var pixX0 = pix10 * remainderX + pix00 * (1.0 - remainderX);
        var pixX1 = pix11 * remainderX + pix01 * (1.0 - remainderX);
        var pixY = pixX1 * remainderY + pixX0 * (1.0 - remainderY);
        return pixY;
      }
      function GetPixelBilinearXPos(imageData, x, y) {
        var floorX = x | 0;
        var floorY = y | 0;
        var remainderX = x - floorX;
        var pix00 = GetPixelR(imageData, floorX, floorY);
        var pix10 = GetPixelR(imageData, floorX + 1, floorY);

        var pixX0 = pix10 * remainderX + pix00 * (1.0 - remainderX);
        return pixX0;
      }
      function GetPixelR(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 0];
      }
      function GetPixelG(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 1];
      }
      function GetPixelB(imageData, x, y) {
        if (!InRange(imageData, x, y)) return 0;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 2];
      }
      function SetPixelR(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 0] = pix;
      }
      function SetPixelG(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 1] = pix;
      }
      function SetPixelB(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 2] = pix;
      }
      function SetPixelA(imageData, x, y, pix) {
        imageData.data[((y*(imageData.width*4)) + (x*4)) + 3] = pix;
      }
      function SetPixelF(x, y, pix) {
        bufferF[y*widthF + x] = pix;
      }
      function GetPixelF(x, y) {
        if (x < 0) return 0.0;
        if (y < 0) return 0.0;
        if (x >= widthF) return 0.0;
        if (y >= heightF) return 0.0;
        return bufferF[y*widthF + x];
      }
      function GetPixelFTile(tx, ty, x, y) {
        var left = ((tx / cellSize) | 0) * cellSize;
        var top = ((ty / cellSize) | 0) * cellSize;
        var right = ((tx / cellSize) | 0) * cellSize + cellSize - 1;
        var bottom = ((ty / cellSize) | 0) * cellSize + cellSize - 1;
        if (x < left) x = left;
        if (y < top) y = top;
        if (x > right) x = right;
        if (y > bottom) y = bottom;
        return bufferF[y*widthF + x];
      }
      function GetPixelRTile(imageData, tx, ty, x, y) {
        var left = ((tx / cellSize) | 0) * cellSize;
        var top = ((ty / cellSize) | 0) * cellSize;
        var right = ((tx / cellSize) | 0) * cellSize + cellSize - 1;
        var bottom = ((ty / cellSize) | 0) * cellSize + cellSize - 1;
        if (x < left) x = left;
        if (y < top) y = top;
        if (x > right) x = right;
        if (y > bottom) y = bottom;
        return imageData.data[((y*(imageData.width*4)) + (x*4)) + 0];
      }

      function Lerp2(x, y, a) {
        var result = [0, 0];
        result[0] = y[0] * a + x[0] * (1.0 - a);
        result[1] = y[1] * a + x[1] * (1.0 - a);
        return result;
      }
      // These arrays tell the program which of the 4 edges need to be interpolated to make
      // a line. They are pairs because they represent the line end points.
      var lineIndex1 = [[-1,-1], [3,0], [0,1], [3,1], [1,2], [3,0], [0,2], [3,2],
                        [2,3], [2,0], [0,1], [2,1], [1,3], [1,0], [0,3], [-1,-1]];
      // It is possible (in 2 cases) that one block will make 2 lines. This array defines
      // the second line.
      var lineIndex2 = [[-1,-1], [-1,-1], [-1,-1], [-1,-1], [-1,-1], [1,2], [-1,-1], [-1,-1],
                        [-1,-1], [-1,-1], [2,3], [-1,-1], [-1,-1], [-1,-1], [-1,-1], [-1,-1]];


      function Vectorize(imageData) {
        var threshold = 128;
        //List<float4> v = new List<float4>();
        var v = [];
        //float2[] vertList = new float2[4];
        var vertList = [[0,0],[0,0],[0,0],[0,0]];
        for (var y = 0; y < imageData.height - 1; y++)
        {
          for (var x = 0; x < imageData.width - 1; x++)
          {
            var pix00 = GetPixelR(imageData, x, y);
            var pix10 = GetPixelR(imageData, x + 1, y);
            var pix01 = GetPixelR(imageData, x, y + 1);
            var pix11 = GetPixelR(imageData, x + 1, y + 1);

            var squareIndex = 0 | 0;
            if (pix00 < threshold) squareIndex |= 1;
            if (pix10 < threshold) squareIndex |= 2;
            if (pix11 < threshold) squareIndex |= 4;
            if (pix01 < threshold) squareIndex |= 8;
            if ((squareIndex == 0) || (squareIndex == 0xf)) continue;

            // middle of the pixel is in upper left. is this what we want?
            var pos00 = [x, y];
            var pos10 = [x + 1, y];
            var pos01 = [x, y + 1];
            var pos11 = [x + 1, y + 1];
            // interpolate the 4 edges. Not all 4 are always used, so with effort, this could be optimized.
            // also, the horizontal and vertical pos variables are very integery and this could be optimized.
            // these could also be shifted left like the other variables.
            vertList[0] = Lerp2(pos00, pos10, (threshold*1.0 - pix00) / (pix10*1.0 - pix00));
            vertList[1] = Lerp2(pos10, pos11, (threshold*1.0 - pix10) / (pix11*1.0 - pix10));
            vertList[2] = Lerp2(pos11, pos01, (threshold*1.0 - pix11) / (pix01*1.0 - pix11));
            vertList[3] = Lerp2(pos01, pos00, (threshold*1.0 - pix01) / (pix00*1.0 - pix01));

            var vertA = lineIndex1[squareIndex][0];
            var vertB = lineIndex1[squareIndex][1];
            var vert2A = lineIndex2[squareIndex][0];
            var vert2B = lineIndex2[squareIndex][1];

            // put final lines in the line list
            if (vertA != -1)
            {
              v.push([vertList[vertA][0]+0.0, vertList[vertA][1]+0.0, vertList[vertB][0]+0.0, vertList[vertB][1]+0.0]);
              // SetPixelG(myImageData, vertList[vertA][0] | 0, vertList[vertA][1] | 0, 255);
            }
            if (vert2A != -1)
            {
              v.push([vertList[vert2A][0]+0.0, vertList[vert2A][1]+0.0, vertList[vert2B][0]+0.0, vertList[vert2B][1]+0.0]);
            }
          }
        }
        return v;
      }


      function GenChar() {
        canvas = createTextCanvas('white', undefined);
        document.body.appendChild(canvas);

        canvas.onclick = function(e) {
          e = e || window.event
          var rect = canvas.getBoundingClientRect();
          var mousex = e.clientX - rect.left;
          var mousey = e.clientY - rect.top;
          var pixG = GetPixelG(newImg, mousex, mousey);
          var pixB = GetPixelB(newImg, mousex, mousey);
          console.log('[' + mousex + ',' + mousey + ']' + 'Green: ' + pixG + "   Blue: " + pixB);
        }
      }

      function autorun()
      {
        GenChar();
        document.body.style.background = "#888";
      }
      if (document.addEventListener) document.addEventListener("DOMContentLoaded", autorun, false);
      else if (document.attachEvent) document.attachEvent("onreadystatechange", autorun);
      else window.onload = autorun;
    </script>
  </body>
</html>
